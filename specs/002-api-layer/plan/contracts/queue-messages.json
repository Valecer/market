{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Redis Queue Message Contracts",
  "description": "Message formats for Redis queue communication between Bun API and Python worker",
  "version": "1.0.0",
  "queueNames": {
    "parseTasks": "parse-tasks",
    "description": "Queue for supplier data ingestion tasks"
  },
  "messages": {
    "parseTask": {
      "queueName": "parse-tasks",
      "direction": "Bun API â†’ Python Worker",
      "schema": {
        "$ref": "#/definitions/ParseTaskMessage"
      },
      "notes": {
        "serialization": "JSON.stringify() before LPUSH",
        "compatibility": "Must match Phase 1 Python worker expectations (Pydantic model)",
        "idempotency": "task_id must be unique UUID for deduplication"
      }
    }
  },
  "definitions": {
    "ParseTaskMessage": {
      "type": "object",
      "required": [
        "task_id",
        "parser_type",
        "supplier_name",
        "source_config",
        "retry_count",
        "max_retries",
        "enqueued_at"
      ],
      "properties": {
        "task_id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique task identifier (generated by API using crypto.randomUUID())"
        },
        "parser_type": {
          "type": "string",
          "enum": ["google_sheets", "csv", "excel"],
          "description": "Parser type matching supplier.source_type"
        },
        "supplier_name": {
          "type": "string",
          "maxLength": 255,
          "description": "Supplier name for logging (from suppliers.name)"
        },
        "source_config": {
          "type": "object",
          "description": "Parser-specific configuration (from suppliers.metadata JSONB)",
          "properties": {
            "spreadsheet_url": {
              "type": "string",
              "format": "uri",
              "description": "Google Sheets URL (for google_sheets parser)"
            },
            "sheet_name": {
              "type": "string",
              "description": "Sheet name within spreadsheet (optional)"
            },
            "file_path": {
              "type": "string",
              "description": "File path for CSV/Excel parser"
            },
            "column_mapping": {
              "type": "object",
              "description": "Mapping of expected columns to actual sheet headers",
              "properties": {
                "sku": {
                  "type": "string",
                  "example": "SKU"
                },
                "name": {
                  "type": "string",
                  "example": "Product Name"
                },
                "price": {
                  "type": "string",
                  "example": "Price"
                }
              }
            }
          },
          "additionalProperties": true,
          "description": "Configuration is parser-specific and stored as JSONB"
        },
        "retry_count": {
          "type": "integer",
          "minimum": 0,
          "default": 0,
          "description": "Current retry attempt (0 for first attempt)"
        },
        "max_retries": {
          "type": "integer",
          "minimum": 0,
          "default": 3,
          "description": "Maximum retry attempts before dead-letter queue"
        },
        "enqueued_at": {
          "type": "string",
          "format": "date-time",
          "description": "ISO-8601 timestamp when task was enqueued"
        }
      },
      "additionalProperties": false,
      "example": {
        "task_id": "990e8400-e29b-41d4-a716-446655440000",
        "parser_type": "google_sheets",
        "supplier_name": "TechSupplier Inc",
        "source_config": {
          "spreadsheet_url": "https://docs.google.com/spreadsheets/d/abc123/edit",
          "sheet_name": "Price List",
          "column_mapping": {
            "sku": "SKU",
            "name": "Product Name",
            "price": "Unit Price"
          }
        },
        "retry_count": 0,
        "max_retries": 3,
        "enqueued_at": "2025-11-26T10:30:00Z"
      }
    }
  },
  "implementation": {
    "bunApi": {
      "publishExample": {
        "typescript": "```typescript\nimport Redis from 'ioredis'\n\nconst redis = new Redis(process.env.REDIS_URL)\n\nconst message: ParseTaskMessage = {\n  task_id: crypto.randomUUID(),\n  parser_type: supplier.source_type,\n  supplier_name: supplier.name,\n  source_config: supplier.metadata,\n  retry_count: 0,\n  max_retries: 3,\n  enqueued_at: new Date().toISOString()\n}\n\nawait redis.lpush(\n  process.env.REDIS_QUEUE_NAME || 'parse-tasks',\n  JSON.stringify(message)\n)\n```"
      }
    },
    "pythonWorker": {
      "consumeExample": {
        "python": "```python\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\nfrom typing import Literal\n\nclass ParseTaskMessage(BaseModel):\n    task_id: str = Field(..., description=\"UUID v4\")\n    parser_type: Literal['google_sheets', 'csv', 'excel']\n    supplier_name: str\n    source_config: dict\n    retry_count: int = Field(default=0, ge=0)\n    max_retries: int = Field(default=3, ge=0)\n    enqueued_at: datetime\n\n# Worker consumption (arq)\nasync def parse_supplier_data(ctx, task_json: str):\n    message = ParseTaskMessage.parse_raw(task_json)\n    # Process task...\n```"
      }
    }
  },
  "errorHandling": {
    "redisUnavailable": {
      "apiResponse": "503 Service Unavailable",
      "errorCode": "REDIS_UNAVAILABLE",
      "message": "Queue service is temporarily unavailable"
    },
    "workerFailure": {
      "retryLogic": "Exponential backoff: 1s, 5s, 25s",
      "deadLetterQueue": "After max_retries exceeded, move to 'parse-tasks:failed'",
      "loggingDestination": "parsing_logs table in PostgreSQL"
    }
  },
  "monitoring": {
    "metrics": [
      "Queue depth (LLEN parse-tasks)",
      "Tasks published per minute",
      "Average task age in queue",
      "Dead letter queue size"
    ]
  },
  "compatibility": {
    "phase1Worker": {
      "version": "1.0.0",
      "pydanticModel": "src.models.queue_messages.ParseTaskMessage",
      "validationNotes": "Phase 1 worker validates using Pydantic strict mode - ensure all fields match exactly"
    }
  }
}
